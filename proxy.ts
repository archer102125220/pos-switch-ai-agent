import { NextResponse } from 'next/server';
import { type NextRequest } from 'next/server';
import createIntlMiddleware from 'next-intl/middleware';
import { routing } from './i18n/routing';

const intlMiddleware = createIntlMiddleware(routing);

// Admin permissions that indicate user should go to /admin
const ADMIN_PERMISSIONS = [
  'users', 'roles', 'permissions', 'products', 
  'categories', 'addons', 'system_settings'
];

// POS permissions
const POS_PERMISSIONS = ['checkout', 'order_history'];

/**
 * Check if CORS is enabled via environment variable
 */
function isCorsEnabled(): boolean {
  return process.env.ENABLE_CORS === 'true';
}

/**
 * Get list of allowed origins from environment
 */
function getAllowedOrigins(): string[] {
  const originsStr = process.env.CORS_ALLOWED_ORIGINS || '';
  if (!originsStr.trim()) {
    return [];
  }
  return originsStr.split(',').map(origin => origin.trim()).filter(Boolean);
}

/**
 * Check if an origin is allowed
 */
function isOriginAllowed(origin: string | null): boolean {
  if (!origin) return false;
  
  const allowedOrigins = getAllowedOrigins();
  
  // If no specific origins set, allow all when CORS is enabled
  if (allowedOrigins.length === 0 && isCorsEnabled()) {
    return true;
  }
  
  return allowedOrigins.includes(origin);
}

/**
 * Get CORS headers for a request
 */
function getCorsHeaders(request: NextRequest): Record<string, string> {
  if (!isCorsEnabled()) {
    return {};
  }

  const origin = request.headers.get('origin');
  const headers: Record<string, string> = {};

  // Check if origin is allowed
  if (origin && isOriginAllowed(origin)) {
    headers['Access-Control-Allow-Origin'] = origin;
    headers['Access-Control-Allow-Credentials'] = 'true';
    headers['Access-Control-Allow-Methods'] = 'GET, POST, PUT, DELETE, OPTIONS';
    headers['Access-Control-Allow-Headers'] = 'Content-Type, Authorization';
    headers['Access-Control-Max-Age'] = '86400'; // 24 hours
  } else if (isCorsEnabled() && getAllowedOrigins().length === 0) {
    // Allow all origins when CORS enabled but no specific origins set
    headers['Access-Control-Allow-Origin'] = origin || '*';
    headers['Access-Control-Allow-Credentials'] = origin ? 'true' : 'false';
    headers['Access-Control-Allow-Methods'] = 'GET, POST, PUT, DELETE, OPTIONS';
    headers['Access-Control-Allow-Headers'] = 'Content-Type, Authorization';
    headers['Access-Control-Max-Age'] = '86400';
  }

  return headers;
}

/**
 * Handle CORS preflight (OPTIONS) request
 */
function handleCorsPreflightRequest(request: NextRequest): NextResponse | null {
  if (request.method !== 'OPTIONS') {
    return null;
  }

  if (!isCorsEnabled()) {
    // If CORS is disabled, OPTIONS requests should be handled by the route
    return null;
  }

  const corsHeaders = getCorsHeaders(request);
  
  if (Object.keys(corsHeaders).length === 0) {
    return new NextResponse(null, { status: 403 });
  }

  return new NextResponse(null, {
    status: 204,
    headers: corsHeaders,
  });
}

/**
 * Add CORS headers to an existing response
 */
function addCorsHeaders(response: NextResponse, request: NextRequest): NextResponse {
  if (!isCorsEnabled()) {
    return response;
  }

  const corsHeaders = getCorsHeaders(request);
  
  Object.entries(corsHeaders).forEach(([key, value]) => {
    response.headers.set(key, value);
  });
  
  return response;
}

export default async function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl;
  
  // Handle API routes with CORS
  if (pathname.startsWith('/api/')) {
    // Handle preflight OPTIONS request
    const preflightResponse = handleCorsPreflightRequest(request);
    if (preflightResponse) {
      return preflightResponse;
    }
    
    // For non-preflight API requests, add CORS headers to the response
    // Note: The actual response will be generated by the API route
    // We just need to pass through but middleware can't modify downstream responses
    // CORS headers will be added in the route handlers using utils/cors.ts
    return NextResponse.next();
  }
  
  // Execute i18n middleware for non-API routes
  const intlResponse = intlMiddleware(request);
  
  // Extract locale from pathname (e.g., /zh-tw/admin -> zh-tw)
  const localeMatch = pathname.match(/^\/(zh-tw|en)/);
  const locale = localeMatch ? localeMatch[1] : 'zh-tw';
  
  // Check if this is a protected route
  const isAdminRoute = pathname.match(/^\/(zh-tw|en)\/admin/);
  const isPosRoute = pathname.match(/^\/(zh-tw|en)\/pos/);
  const isLoginPage = pathname.match(/^\/(zh-tw|en)\/login/);
  const isProtectedRoute = isAdminRoute || isPosRoute;
  
  // Get access token from cookies
  const accessToken = request.cookies.get('access_token')?.value;
  
  let userPermissions: string[] = [];
  
  if (accessToken) {
    try {
      // Decode JWT to get permissions (basic decode, not verification)
      const payload = JSON.parse(
        Buffer.from(accessToken.split('.')[1], 'base64').toString()
      );
      userPermissions = payload.permissions || [];
    } catch (error) {
      // Invalid token format, treat as unauthenticated
      console.error('Invalid token format:', error);
    }
  }
  
  // Route Protection Logic
  
  // 1. Unauthenticated user trying to access protected route -> redirect to login
  if (isProtectedRoute && !accessToken) {
    const loginUrl = new URL(`/${locale}/login`, request.url);
    return NextResponse.redirect(loginUrl);
  }
  
  // 2. Authenticated user trying to access login page -> redirect based on permissions
  if (isLoginPage && accessToken) {
    const hasAdminPerms = userPermissions.some(p => ADMIN_PERMISSIONS.includes(p));
    const redirectPath = hasAdminPerms ? `/${locale}/admin` : `/${locale}/pos`;
    const redirectUrl = new URL(redirectPath, request.url);
    return NextResponse.redirect(redirectUrl);
  }
  
  // 3. Root path (/) -> redirect to login if not authenticated, or to appropriate dashboard
  if (pathname === `/${locale}` || pathname === `/${locale}/`) {
    if (!accessToken) {
      const loginUrl = new URL(`/${locale}/login`, request.url);
      return NextResponse.redirect(loginUrl);
    } else {
      const hasAdminPerms = userPermissions.some(p => ADMIN_PERMISSIONS.includes(p));
      const redirectPath = hasAdminPerms ? `/${locale}/admin` : `/${locale}/pos`;
      const redirectUrl = new URL(redirectPath, request.url);
      return NextResponse.redirect(redirectUrl);
    }
  }
  
  return intlResponse;
}

export const config = {
  // Match internationalized pathnames, root, and API routes
  matcher: ['/', '/(zh-tw|en)/:path*', '/api/:path*'],
};

